# StealthKitty - Projet Robot Chat

## Description
StealthKitty est un projet de syst√®me embarqu√© innovant bas√© sur un STM32. L'objectif est de d√©velopper plusieurs robots capables de se d√©placer sur une table sans bordure. Un robot est d√©sign√© comme "chat" et doit attraper un autre robot, qui devient alors le nouveau "chat". Ceci est un projet de derni√®re ann√©e de la meilleure fili√®re de l'ENSEA : √©lectronique et syst√®mes embarqu√©s (ESE)

Les contributeurs de ce projet sont :

**- Vincent LAKHMECHE**  
**- Mohamed Rafik CHAIR**  
**- Meziane Ameur**  
**- Karim JERJOUB**

![image](https://github.com/user-attachments/assets/0b8a3520-2e76-4162-91c8-48ae93badee7)

## Table des mati√®res
1. [Contexte](#contexte)  
2. [Fonctionnalit√©s](#fonctionnalit√©s)  
3. [Mat√©riel utilis√©](#mat√©riel-utilis√©)  
4. [Architecture](#architecture)  
5. [Utilisation](#utilisation)  
6. [Auteurs](#auteurs)  
7. [Licence](#licence)

## Contexte
Ce projet s'inscrit dans le cadre de la formation 3A √† l'ENSEA. Il vise √† concevoir un syst√®me embarqu√© complet, de la conception √©lectronique √† l'impl√©mentation logicielle.

## Fonctionnalit√©s
- D√©tection de bords via des capteurs ToF.
- Communication entre robots pour synchronisation.
- Algorithme de poursuite et d'√©vitement.
- Gestion des moteurs via des signaux PWM.

## Mat√©riel utilis√©
- **STM32G431RB** : Microcontr√¥leur principal.
- **Capteurs ToF** : D√©tection des bordures.
- **LiDAR** : Cartographie de l'environnement et d√©tection des autres robots.
- **Acc√©l√©rom√®tre** : D√©tection des chocs avec les autres robots afin de changer de r√¥le (Chat/Souris).
- **STM32CubeIDE** : Environnement de d√©veloppement.

## Architecture
### Sch√©ma architectural
Le sch√©ma suivant illustre l'architecture g√©n√©rale du projet :  

![image](https://github.com/user-attachments/assets/0f7c4c1b-3890-4360-bbe3-213a3acfd5ad)

### Explication du fonctionnement du syst√®me

1. **Alimentation principale**
   - La **batterie NiMH 7.2V 1.3Ah** alimente l'ensemble du syst√®me. Elle est connect√©e √† des r√©gulateurs de tension pour fournir les diff√©rentes tensions n√©cessaires aux composants du robot.

2. **R√©gulateurs de tension**
   - **MP1475S** : R√©gulateur 5V pour alimenter les moteurs et certains capteurs.
   - **BU33SD5WG-TR** : R√©gulateur 3.3V pour alimenter le microcontr√¥leur STM32G431, l'acc√©l√©rom√®tre et le LiDAR.

3. **Microcontr√¥leur principal - STM32G431**
   - Le **STM32G431** g√®re toute la logique du robot et communique avec les diff√©rents composants via des bus tels que SPI, UART, I2C et PWM.
   - Il est reli√© √† un **quartz 16 MHz** pour la gestion de l'horloge syst√®me et dispose d'un connecteur **SWD** pour la programmation et le d√©bogage.

4. **Capteurs**
   - **Capteurs de bordure** : Utilis√©s pour d√©tecter les bords ou les chutes du robot.
   - **ADXL343 (Acc√©l√©rom√®tre)** : D√©tecte les impacts ou les tapotements (utilis√© pour d√©tecter les collisions avec d'autres robots). Il est connect√© au bus **SPI**.
   - **LiDAR YDLIDAR X4** : Permet de d√©tecter les obstacles √† l'aide de la communication **UART** pour transmettre les donn√©es de distance et d'angle.

5. **Contr√¥le des moteurs**
   - **ZXBM5210-SP-13 (Driver de moteur)** : Utilis√© pour contr√¥ler la direction et la vitesse des moteurs √† l'aide de signaux **PWM**. Le microcontr√¥leur STM32 contr√¥le les moteurs via le driver pour ajuster la vitesse et la direction du robot.

6. **Indicateurs d'√©tat (LEDs)**
   - Les **LEDs** servent d'indicateurs pour visualiser l'√©tat du robot, par exemple, lorsque le robot est en marche ou lorsqu'il d√©tecte un obstacle.

### D√©tails des principaux outils utilis√©s

1. **Communication avec l'acc√©l√©rom√®tre (ADXL343)** :
   - Utilisation du protocole SPI pour lire les donn√©es des axes X, Y et Z.
   - D√©tection des chocs (taps) caus√©s par des collisions avec d'autres robots.

2. **Contr√¥le des moteurs avec le driver ZXBM5210** :
   - G√©n√©ration de signaux PWM pour r√©guler la vitesse des moteurs.
   - Impl√©mentation des mouvements du robot : avancer, reculer, tourner √† gauche ou √† droite.

3. **Gestion des capteurs de bordure/d√©tection de chute** :
   - Lecture des entr√©es des capteurs pour d√©tecter les bords de la table.
   - R√©action imm√©diate pour stopper ou changer de direction afin d‚Äô√©viter une chute.

4. **Interfa√ßage avec le LiDAR YDLIDAR X4** :
   - Communication via UART pour lire les donn√©es du LiDAR.
   - Extraction des valeurs d‚Äôangles et de distances pour cartographier l'environnement et √©viter les obstacles.

---

## R√©alisation mat√©rielle
La partie mat√©rielle a √©t√© con√ßue avec **KiCad 8.0** et comprend :
- **Sch√©ma √©lectronique** : Disponible dans le [dossier hardware](./hardware/).
- **PCB rout√©** : Les fichiers de routage sont inclus dans le dossier.
- **BOM (Bill of Materials)** : Liste des composants n√©cessaires.
- **Fichiers GERBER** : Pour la fabrication chez **JLCPCB**.

## D√©veloppement logiciel
Le logiciel embarqu√© a √©t√© d√©velopp√© avec **STM32CubeIDE** et comprend :  

- **Configuration des p√©riph√©riques** : SPI, UART, PWM, et autres param√®tres mat√©riels, configur√©s via le fichier `.ioc`.  
- **Modules logiciels** : Gestion des capteurs, contr√¥le des moteurs, et communication.  
- **Algorithmes embarqu√©s** : Impl√©mentation des comportements du robot (d√©tection des bords, poursuite, et √©vitement).  

Tout le code source et les configurations sont centralis√©s dans le dossier [Software](./Software).





# üê± **StealthKitty - Projet Robot Chat**  

 <img src="https://megabase.eduniversal.com/uploads/school/1155/logo.jpg?v=c7e3965d14625a3e4b5662bd550d93e0" alt="Logo ENSEA" width="40"/> ![STM32](https://img.shields.io/badge/STM32-Embedded-blue?style=for-the-badge&logo=stmicroelectronics)  
[![ENSEA](https://img.shields.io/badge/ENSEA-3A--ESE-green?style=for-the-badge&logo=https://upload.wikimedia.org/wikipedia/fr/8/82/Logo_ENSEA.svg)](https://www.ensea.fr)
![Status](https://img.shields.io/badge/Status-Finished-orange?style=for-the-badge)  


---

## üìú **Description**  
StealthKitty est un projet de **syst√®me embarqu√© innovant** bas√© sur un **STM32**.  
üéØ **Objectif :** D√©velopper plusieurs robots capables de se d√©placer sur une table sans bordure.  
- üêæ Un robot est d√©sign√© comme **"chat"** et doit attraper un autre robot, qui devient alors le nouveau **"chat"**.  

Ce projet est r√©alis√© dans le cadre de la derni√®re ann√©e de la fili√®re **√©lectronique et syst√®mes embarqu√©s (ESE)** de l'ENSEA.

### **Les contributeurs :**  
- üë®‚Äçüíª **Vincent LAKHMECHE**  
- üë®‚Äçüíª **Mohamed Rafik CHAIR**  
- üë®‚Äçüíª **Meziane Ameur**  
- üë®‚Äçüíª **Karim JERJOUB**  

---

## üìö **Table des mati√®res**  
1. [üìñ Contexte](#-contexte)  
2. [‚ú® Fonctionnalit√©s](#-fonctionnalit√©s)  
3. [üîß Mat√©riel utilis√©](#-mat√©riel-utilis√©)  
4. [üìê Architecture](#-architecture)  
5. [üöÄ Utilisation](#-utilisation)  
6. [üë• Auteurs](#-auteurs)  
7. [üìÑ Licence](#-licence)  

---

## üìñ **Contexte**  
Ce projet s'inscrit dans le cadre de la formation 3A √† l'ENSEA.  
üéØ L'objectif est de concevoir un syst√®me embarqu√© complet, depuis la conception √©lectronique jusqu'√† l'impl√©mentation logicielle.

---

## ‚ú® **Fonctionnalit√©s**  
- üõ°Ô∏è **D√©tection de bords** via des capteurs ToF.  
- üîÑ **Communication entre robots** pour synchronisation.  
- üéØ **Algorithme de poursuite et d'√©vitement.**  
- ‚öôÔ∏è **Gestion des moteurs** √† l'aide de signaux PWM.  

---

## üîß **Mat√©riel utilis√©**  
- **STM32G431RB** : Microcontr√¥leur principal.  
- **Capteurs ToF** : D√©tection des bordures.  
- **LiDAR** : Cartographie et d√©tection d'autres robots.  
- **Acc√©l√©rom√®tre (ADXL343)** : D√©tection des chocs pour changer de r√¥le (Chat/Souris).  
- **Environnement de d√©veloppement :** STM32CubeIDE.  

---

## üìê **Architecture**  
### **Sch√©ma architectural**  
![image](https://github.com/user-attachments/assets/0f7c4c1b-3890-4360-bbe3-213a3acfd5ad)
### Explication du fonctionnement du syst√®me

1. **Alimentation principale**
   - La **batterie NiMH 7.2V 1.3Ah** alimente l'ensemble du syst√®me. Elle est connect√©e √† des r√©gulateurs de tension pour fournir les diff√©rentes tensions n√©cessaires aux composants du robot.

2. **R√©gulateurs de tension**
   - **MP1475S** : R√©gulateur 5V pour alimenter les moteurs et certains capteurs.
   - **BU33SD5WG-TR** : R√©gulateur 3.3V pour alimenter le microcontr√¥leur STM32G431, l'acc√©l√©rom√®tre et le LiDAR.

3. **Microcontr√¥leur principal - STM32G431**
   - Le **STM32G431** g√®re toute la logique du robot et communique avec les diff√©rents composants via des bus tels que SPI, UART, I2C et PWM.
   - Il est reli√© √† un **quartz 16 MHz** pour la gestion de l'horloge syst√®me et dispose d'un connecteur **SWD** pour la programmation et le d√©bogage.

4. **Capteurs**
   - **Capteurs de bordure** : Utilis√©s pour d√©tecter les bords ou les chutes du robot.
   - **ADXL343 (Acc√©l√©rom√®tre)** : D√©tecte les impacts ou les tapotements (utilis√© pour d√©tecter les collisions avec d'autres robots). Il est connect√© au bus **SPI**.
   - **LiDAR YDLIDAR X4** : Permet de d√©tecter les obstacles √† l'aide de la communication **UART** pour transmettre les donn√©es de distance et d'angle.

5. **Contr√¥le des moteurs**
   - **ZXBM5210-SP-13 (Driver de moteur)** : Utilis√© pour contr√¥ler la direction et la vitesse des moteurs √† l'aide de signaux **PWM**. Le microcontr√¥leur STM32 contr√¥le les moteurs via le driver pour ajuster la vitesse et la direction du robot.

6. **Indicateurs d'√©tat (LEDs)**
   - Les **LEDs** servent d'indicateurs pour visualiser l'√©tat du robot, par exemple, lorsque le robot est en marche ou lorsqu'il d√©tecte un obstacle.

### D√©tails des principaux outils utilis√©s

1. **Communication avec l'acc√©l√©rom√®tre (ADXL343)** :
   - Utilisation du protocole SPI pour lire les donn√©es des axes X, Y et Z.
   - D√©tection des chocs (taps) caus√©s par des collisions avec d'autres robots.

2. **Contr√¥le des moteurs avec le driver ZXBM5210** :
   - G√©n√©ration de signaux PWM pour r√©guler la vitesse des moteurs.
   - Impl√©mentation des mouvements du robot : avancer, reculer, tourner √† gauche ou √† droite.

3. **Gestion des capteurs de bordure/d√©tection de chute** :
   - Lecture des entr√©es des capteurs pour d√©tecter les bords de la table.
   - R√©action imm√©diate pour stopper ou changer de direction afin d‚Äô√©viter une chute.

4. **Interfa√ßage avec le LiDAR YDLIDAR X4** :
   - Communication via UART pour lire les donn√©es du LiDAR.
   - Extraction des valeurs d‚Äôangles et de distances pour cartographier l'environnement et √©viter les obstacles.

---

### **Explication du syst√®me**  
1. **‚ö° Alimentation principale**  
   - Batterie **NiMH 7.2V 1.3Ah**, connect√©e √† des r√©gulateurs de tension (**MP1475S**, **BU33SD5WG-TR**) pour alimenter les composants.

2. **üñ•Ô∏è Microcontr√¥leur principal - STM32G431**  
   - G√®re toute la logique du robot via SPI, UART, I2C et PWM.

3. **üîç Capteurs**  
   - **Capteurs ToF** pour d√©tecter les bords.  
   - **Acc√©l√©rom√®tre ADXL343** pour les chocs (via SPI).  
   - **LiDAR YDLIDAR X4** pour cartographier l‚Äôenvironnement (via UART).  

4. **‚öôÔ∏è Contr√¥le des moteurs**  
   - **ZXBM5210-SP-13** : Contr√¥le la vitesse et la direction des moteurs via PWM.

5. **üåü LEDs**  
   - Indicateurs pour visualiser l‚Äô√©tat du robot (en marche, d√©tection d‚Äôobstacle, etc.).

---

## üöÄ **R√©alisation mat√©rielle**  
La partie mat√©rielle a √©t√© con√ßue avec **KiCad 8.0** et comprend :  
- üìú **Sch√©ma √©lectronique**  
- üß© **PCB rout√©**  
- üõ†Ô∏è **BOM (Bill of Materials)**  
- üóÇÔ∏è **Fichiers GERBER** pour fabrication chez **JLCPCB**.  

### üîë [Acc√©dez aux fichiers hardware ici.](./hardware/)

---

## üõ†Ô∏è **D√©veloppement logiciel**  
Le logiciel embarqu√© a √©t√© d√©velopp√© avec **STM32CubeIDE** et inclut :  
- üîß **Configuration des p√©riph√©riques** (SPI, UART, PWM, etc.).  
- üì¶ **Modules logiciels** pour capteurs et moteurs.  
- ü§ñ **Algorithmes embarqu√©s** pour les comportements du robot (poursuite, √©vitement, etc.).  

### üìÇ [Acc√©dez au code source ici.](./Software)

---

## üë• **Auteurs**  
- **Vincent LAKHMECHE**  
- **Mohamed Rafik CHAIR**  
- **Meziane Ameur**  
- **Karim JERJOUB**

---

## üìÑ **Licence**  
üìù Ce projet est sous licence **MIT**.  
Pour plus d‚Äôinformations, consultez le fichier [LICENSE](./LICENSE).  


# üöÄ Utilisation de l'acc√©l√©rom√®tre ADXL343 dans le robot chat

![STM32](https://img.shields.io/badge/STM32-Embedded-blue?style=for-the-badge&logo=stmicroelectronics)
![FreeRTOS](https://img.shields.io/badge/FreeRTOS-Real--Time--OS-green?style=for-the-badge&logo=freertos)

---

## üéØ Objectifs principaux
- ‚ú® **D√©tecter les tapotements** (Single Tap/Double Tap) pour **changer de r√¥le** entre le robot "chat" et le robot "souris".
- üìä Lire les valeurs d'acc√©l√©ration sur les axes **X, Y, Z** *(optionnel)*.

---

## ‚öôÔ∏è Configuration
- **Plage d'acc√©l√©ration :** ¬±2 g *(pr√©cision pour petits mouvements)*.
- **Registres utilis√©s :**  
  - üõ†Ô∏è `POWER_CTL` : Activer le mode mesure.  
  - üéöÔ∏è `THRESH_TAP`, `DUR`, `INT_ENABLE` : Configurer les seuils et activer les interruptions pour les tapotements.  
  - üñ•Ô∏è `INT_SOURCE` : V√©rifier les √©v√©nements de tapotements.

---

## üîß Fonctionnalit√©s impl√©ment√©es
### ‚úÖ D√©tection des tapotements
- üîÑ V√©rifie les interruptions via le registre `INT_SOURCE`.
- üìç Met √† jour la variable globale `tap_detected` pour signaler un √©v√©nement.

### ‚úÖ Lecture des acc√©l√©rations
- üì• R√©cup√©ration des valeurs brutes : `acc_rawX`, `acc_rawY`, `acc_rawZ`.
- üîÑ Conversion des valeurs en unit√©s normalis√©es (*g*) via un facteur de calibration.

---

## üîÅ R√©actions aux tapotements
- ‚ö° **Interruptions activ√©es** pour permettre une r√©action en temps r√©el.
- üîÄ Chaque tapotement entra√Æne un **changement de comportement des moteurs** (ex. direction ou r√¥le).

---

## üïí FreeRTOS Task
- Cr√©ation d'une t√¢che principale **`vTaskADX`** pour :  
  1Ô∏è‚É£ Lire les donn√©es d'acc√©l√©ration brutes et normalis√©es.  
  2Ô∏è‚É£ V√©rifier les √©v√©nements de tapotement.  
  3Ô∏è‚É£ Ajouter un d√©lai pour r√©duire la charge CPU (`vTaskDelay`).

---















