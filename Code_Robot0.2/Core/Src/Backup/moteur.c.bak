/*
 * moteur.c
 *
 *  Created on: Dec 4, 2024
 *      Author: ENSEA
 */
#include "moteur.h"
#include <math.h>


extern TIM_HandleTypeDef htim1;
extern TIM_HandleTypeDef htim3; // TIM3 pour l'encodeur moteur droit
extern TIM_HandleTypeDef htim4; // TIM4 pour l'encodeur moteur gauche

void init_motors(void) {
    // Assurez-vous que TIM1 est correctement initialisé dans CubeMX
    HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);   // TIM1_CH1
    HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);   // TIM1_CH2
    HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_1);  // TIM1_CH1N
    HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_2);  // TIM1_CH2N
}



// Fonction avance moteur droit
void forward_r(uint16_t alpha) {
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, alpha);  // TIM1_CH1
    //__HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_2, 0);     // TIM1_CH2N
    HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);   // TIM1_CH1
    //HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_2);   // TIM1_CH2

    HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_1);
}

// Fonction avance moteur gauchej
void forward_l(uint16_t alpha) {
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_2, alpha);  // TIM1_CH2
    //__HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, 0);     // TIM1_CH1N
    HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_2);   // TIM1_CH1
    //HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_1);   // TIM1_CH2

    HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_2);
}

// Fonction recule moteur droit
void reverse_r(uint16_t alpha) {
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_2, alpha); // TIM1_CH2N
    //__HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, 0);      // TIM1_CH1
//    HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);   // TIM1_CH1
    HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_1);   // TIM1_CH2

    HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_1);
    //   HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_1);

}

// Fonction recule moteur gauche
void reverse_l(uint16_t alpha) {
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, alpha); // TIM1_CH1N
   // __HAL_TIM_SET_COMPARE(&htim1, TIM_CH0ANNEL_2, 0);      // TIM1_CH2
    //HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);   // TIM1_CH1
    HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);   // TIM1_CH2

    HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_2);
    //   HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_2);
}

// Fonction stop moteur droit
void stop_r(void) {
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, 0);      // TIM1_CH1
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_2, 0);     // TIM1_CH2N
    HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_1);   // TIM1_CH1N
    HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_2);   // TIM1_CH2

}

// Fonction stop moteur gauche
void stop_l(void) {
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_2, 0);      // TIM1_CH2
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, 0);     // TIM1_CH1N
    HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_1);   // TIM1_CH1N
    HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_2);   // TIM1_CH2
}

// Fonction pour obtenir la position de l'encodeur
int16_t get_encoder_position(uint8_t motor) {
    int16_t position = 0;

    if (motor == MOTOR_LEFT) {
        position = __HAL_TIM_GET_COUNTER(&htim4);  // Lire le compteur du moteur gauche
    } else if (motor == MOTOR_RIGHT) {
        position = __HAL_TIM_GET_COUNTER(&htim3);  // Lire le compteur du moteur droit
    }

    return position;
}

// Fonction pour réinitialiser la position de l'encodeur
void reset_encoder(uint8_t motor) {
    if (motor == MOTOR_LEFT) {
        __HAL_TIM_SET_COUNTER(&htim4, 0);  // Réinitialiser le compteur du moteur gauche
    } else if (motor == MOTOR_RIGHT) {
        __HAL_TIM_SET_COUNTER(&htim3, 0);  // Réinitialiser le compteur du moteur droit
    }
}



// Fonction pour calculer la vitesse à partir de l'encodeur
float calculate_motor_speed(uint8_t motor, uint32_t delta_time_ms, uint16_t encoder_resolution) {
    static int16_t last_position_left = 0;
    static int16_t last_position_right = 0;
    int16_t current_position = get_encoder_position(motor);
    int16_t delta_position;

    if (motor == MOTOR_LEFT) {
        delta_position = current_position - last_position_left;
        last_position_left = current_position;
    } else {
        delta_position = current_position - last_position_right;
        last_position_right = current_position;
    }

    // Calcul de la vitesse (en tours par seconde)
    // 1 tour = encoder_resolution impulsions
    float speed = (delta_position / (float)encoder_resolution) * (1000.0f / delta_time_ms);
    return speed;
}
